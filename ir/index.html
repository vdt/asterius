<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>IR types and transformation passes - Asterius</title>
  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "IR types and transformation passes";
    var mkdocs_page_input_path = "ir.md";
    var mkdocs_page_url = "/asterius/ir/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Asterius</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../building/">Building guide</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../ahc-link/">Using ahc-link</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../jsffi/">JavaScript FFI</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../vault/">The Vault</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../rts-api/">Invoking RTS API in JavaScript</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">IR types and transformation passes</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#ir-types-and-transformation-passes">IR types and transformation passes</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#cmm-ir">Cmm IR</a></li>
        
            <li><a class="toctree-l3" href="#pre-linking-expression-ir">Pre-linking expression IR</a></li>
        
            <li><a class="toctree-l3" href="#the-store">The store</a></li>
        
            <li><a class="toctree-l3" href="#post-linking-expression-ir">Post-linking expression IR</a></li>
        
            <li><a class="toctree-l3" href="#generating-binary-code-via-binaryen">Generating binary code via binaryen</a></li>
        
            <li><a class="toctree-l3" href="#generating-binary-code-via-wasm-toolkit">Generating binary code via wasm-toolkit</a></li>
        
            <li><a class="toctree-l3" href="#generating-javascript-stub-script">Generating JavaScript stub script</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../debugging/">The runtime debugging feature</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../architecture/">Project architecture</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../wasm-in-hs/">Writing WebAssembly code in Haskell</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../webassembly/">WebAssembly as a Haskell compilation target</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../custom-ghc/">About the custom GHC fork</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../readings/">Reading list</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../reports/">Status reports</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Asterius</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>IR types and transformation passes</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/tweag/asterius/edit/master/docs/ir.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="ir-types-and-transformation-passes">IR types and transformation passes</h2>
<p>This section explains various IR types in asterius, and hopefully presents a clear picture of how information flows from Haskell to WebAssembly. (There's a similar section in <code>jsffi.md</code> which explains implementation details of JSFFI)</p>
<h3 id="cmm-ir">Cmm IR</h3>
<p>Everything starts from Cmm, or more specifically, "raw" Cmm which satisfies:</p>
<ul>
<li>All calls are tail calls, parameters are passed by global registers like R1 or on the stack.</li>
<li>All info tables are converted to binary data segments.</li>
</ul>
<p>Check <code>Cmm</code> module in <code>ghc</code> package to get started on Cmm.</p>
<p>Asterius obtains in-memory raw Cmm via:</p>
<ul>
<li><code>cmmToRawCmmHook</code> in our custom GHC fork. This allow us to lay our fingers on Cmm generated by either compiling Haskell modules, or <code>.cmm</code> files (which are in <code>rts</code>)</li>
<li>There is some abstraction in <code>ghc-toolkit</code>, the compiler logic is actually in the <code>Compiler</code> datatype as some callbacks, and <code>ghc-toolkit</code> converts them to hooks, frontend plugins and <code>ghc</code> executable wrappers.</li>
</ul>
<p>There is one minor annoyance with the Cmm types in GHC (or any other GHC IR type): it's very hard to serialize/deserialize them without setting up complicated contexts related to package databases, etc. To experiment with new backends, it's reasonable to marshal to a custom serializable IR first.</p>
<h3 id="pre-linking-expression-ir">Pre-linking expression IR</h3>
<p>We then marshal raw Cmm to an expression IR defined in <code>Asterius.Types</code>. Each compilation unit (Haskell module or <code>.cmm</code> file) maps to one <code>AsteriusModule</code>, and each <code>AsteriusModule</code> is serialized to a <code>.asterius_o</code> object file which will be deserialized at link time. Since we serialize/deserialize a structured expression IR faithfully, it's possible to perform aggressive LTO by traversing/rewriting IR at link time, and that's what we're doing right now.</p>
<p>The expression IR is mostly a Haskell modeling of a subset of <code>binaryen</code>'s expression IR, with some additions:</p>
<ul>
<li><code>Unresolved</code> related variants, which allow us to use a symbol as an expression. At link time, the symbols are re-written to absolute addresses.</li>
<li>Unresolved locals/globals. At link time, unresolved locals are laid out to wasm locals, and unresolved globals (which are really just Cmm global regs) become fields in the global Capability's <code>StgRegTable</code>.</li>
<li><code>EmitErrorMessage</code>, as a placeholder of emitting a string error message then trapping. At link time, such error messages are collected into an "error message pool", and the wasm code is just "calling some error message reporting function with an array index".</li>
<li><code>Null</code>. We're civilized, educated functional programmers and should really be using <code>Maybe Expression</code> in some fields instead of adding a <code>Null</code> constructor, but this is just handy. Blame me.</li>
</ul>
<p>It's possible to encounter things we can't handle in Cmm (unsupported primops, etc). So <code>AsteriusModule</code> also contains compile-time error messages when something isn't supported, but the errors are not reported, instead they are deferred to runtime error messages. (Ideally link-time, but it turns out to be hard)</p>
<p>The symbols are simply converted to Z-encoded strings that also contain module prefixes, and they are assumed to be unique across different compilation units.</p>
<h3 id="the-store">The store</h3>
<p>There's an <code>AsteriusStore</code> type in <code>Asterius.Types</code>. It's an immutable data structure that maps symbols to underlying entities in the expression IR for every single module, and is a critical component of the linker.</p>
<p>Modeling the store as a self-contained data structure makes it pleasant to write linker logic, at the cost of exploding RAM usage. So we implemented a poor man's KV store in <code>Asterius.Store</code> which performs lazy-loading of modules: when initializing the store, we only load the symbols, but not the actual modules; only when a module is "requested" for the first time, we perform deserialization for that module.</p>
<p><code>AsteriusStore</code> supports merging. It's a handy operation, since we can first initialize a "global" store that represents the standard libraries, then make another store based on compiling user input, simply merge the two and we can start linking from the output store.</p>
<h3 id="post-linking-expression-ir">Post-linking expression IR</h3>
<p>At link time, we take <code>AsteriusStore</code> which contains everything (standard libraries and user input code), then performs live-code discovery: starting from a "root symbol set" (something like <code>Main_main_closure</code>), iteratively fetch the entity from the store, traverse the AST and collect new symbols. When we reach a fixpoint, that fixpoint is the outcome of dependency analysis, representing a self-contained wasm module.</p>
<p>We then do some rewriting work on the self contained module: making symbol tables, rewriting symbols to absolute addresses, using our own relooper to convert from control-flow graphs to structured control flow, etc. Most of the logic is in <code>Asterius.Resolve</code>.</p>
<p>The output of linker is <code>Module</code>. It differs from <code>AsteriusModule</code>, and although it shares quite some datatypes with <code>AsteriusModule</code> (for example, <code>Expression</code>), it guarantees that some variants will not appear (for example, <code>Unresolved*</code>). A <code>Module</code> is ready to be fed to a backend which emits real wasm binary code.</p>
<p>There are some useful linker byproducts. For example, there's <code>LinkReport</code> which contains mappings from symbols to addresses which will be lost in wasm binary code, but is still useful for debugging.</p>
<h3 id="generating-binary-code-via-binaryen">Generating binary code via binaryen</h3>
<p>Once we have a <code>Module</code> (which is essentially just Haskell modeling of binaryen C API), we can invoke binaryen to validate it and generate wasm binary code. The low-level bindings are maintained in the <code>binaryen</code> package, and <code>Asterius.Marshal</code> contains the logic to call the imported functions to do actual work.</p>
<h3 id="generating-binary-code-via-wasm-toolkit">Generating binary code via wasm-toolkit</h3>
<p>We can also convert <code>Module</code> to IR types of <code>wasm-toolkit</code>, which is our native Haskell wasm engine. It's now the default backend of <code>ahc-link</code>, but the binaryen backend can still be chosen by <code>ahc-link --binaryen</code>.</p>
<h3 id="generating-javascript-stub-script">Generating JavaScript stub script</h3>
<p>To make it actually run in Node.js/Chrome, we need two pieces of JavaScript code:</p>
<ul>
<li>Common runtime which can be reused across different asterius compiled modules. It's in <code>asterius/rts/rts.js</code>.</li>
<li>Stub code which contains specific information like error messages, etc.</li>
</ul>
<p>The linker generates stub script along with wasm binary code, and concats the runtime and the stub script to a self-contained JavaScript file which can be run or embedded. It's possible to specify JavaScript "target" to either Node.js or Chrome via <code>ahc-link</code> flags.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../debugging/" class="btn btn-neutral float-right" title="The runtime debugging feature">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../rts-api/" class="btn btn-neutral" title="Invoking RTS API in JavaScript"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/tweag/asterius/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../rts-api/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../debugging/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
